{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nconst API_KEY = 'AIzaSyA94zp7rvXJarol8tn4eMPSy7yFvHIXeLg';\nexport const useGoogleMaps = () => {\n  _s();\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const loadGoogleMaps = () => {\n      if (window.google && window.google.maps) {\n        setIsLoaded(true);\n        return;\n      }\n\n      // Ta bort befintliga Google Maps scripts\n      const existingScripts = document.querySelectorAll('script[src*=\"maps.googleapis.com\"]');\n      existingScripts.forEach(script => script.remove());\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=places&callback=initGoogleMaps`;\n      script.async = true;\n      script.defer = true;\n\n      // Skapa global callback funktion\n      window.initGoogleMaps = () => {\n        if (window.google && window.google.maps) {\n          setIsLoaded(true);\n          setError(null);\n        } else {\n          setError('Google Maps API laddades inte korrekt');\n        }\n      };\n      script.onerror = () => {\n        setError('Kunde inte ladda Google Maps API');\n        setIsLoaded(false);\n      };\n      document.head.appendChild(script);\n    };\n    loadGoogleMaps();\n  }, []);\n  const geocodeAddress = useCallback(address => {\n    return new Promise((resolve, reject) => {\n      if (!window.google || !window.google.maps) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n      try {\n        const geocoder = new window.google.maps.Geocoder();\n        geocoder.geocode({\n          address\n        }, (results, status) => {\n          if (status === 'OK' && results && results[0]) {\n            const location = results[0].geometry.location;\n            resolve({\n              lat: location.lat(),\n              lng: location.lng()\n            });\n          } else {\n            reject(new Error(`Geocoding misslyckades: ${status}`));\n          }\n        });\n      } catch (error) {\n        reject(new Error(`Geocoding fel: ${error}`));\n      }\n    });\n  }, []);\n  const getDistanceMatrix = useCallback(async coordinates => {\n    return new Promise((resolve, reject) => {\n      if (!window.google) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n      const service = new window.google.maps.DistanceMatrixService();\n      const origins = coordinates.map(coord => new window.google.maps.LatLng(coord.lat, coord.lng));\n      const destinations = [...origins];\n      service.getDistanceMatrix({\n        origins,\n        destinations,\n        travelMode: window.google.maps.TravelMode.DRIVING,\n        unitSystem: window.google.maps.UnitSystem.METRIC,\n        avoidHighways: false,\n        avoidTolls: false\n      }, (response, status) => {\n        if (status === 'OK') {\n          const matrix = response.rows.map(row => row.elements.map(element => element.distance.value));\n          resolve(matrix);\n        } else {\n          reject(new Error(`Distance Matrix misslyckades: ${status}`));\n        }\n      });\n    });\n  }, []);\n  const solveTSP = useCallback(distanceMatrix => {\n    const n = distanceMatrix.length;\n    if (n <= 1) return [0];\n\n    // Nearest Neighbor heuristik\n    const visited = new Array(n).fill(false);\n    const path = [0];\n    visited[0] = true;\n    for (let i = 1; i < n; i++) {\n      let nearest = -1;\n      let minDistance = Infinity;\n      for (let j = 0; j < n; j++) {\n        if (!visited[j]) {\n          const distance = distanceMatrix[path[path.length - 1]][j];\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearest = j;\n          }\n        }\n      }\n      if (nearest !== -1) {\n        path.push(nearest);\n        visited[nearest] = true;\n      }\n    }\n    return path;\n  }, []);\n  const optimizeRoute = useCallback(async addresses => {\n    if (addresses.length < 2) {\n      return {\n        addresses,\n        isOptimized: false\n      };\n    }\n    setLoading(true);\n    setError(null);\n    try {\n      // Geokoda alla adresser\n      const coordinates = await Promise.all(addresses.map(address => geocodeAddress(address)));\n\n      // Hämta avståndsmatris\n      const distanceMatrix = await getDistanceMatrix(coordinates);\n\n      // Lös TSP\n      const optimalOrder = solveTSP(distanceMatrix);\n\n      // Sortera adresser enligt optimal ordning\n      const optimizedAddresses = optimalOrder.map(index => addresses[index]);\n\n      // Beräkna totalt avstånd\n      let totalDistance = 0;\n      for (let i = 0; i < optimalOrder.length - 1; i++) {\n        totalDistance += distanceMatrix[optimalOrder[i]][optimalOrder[i + 1]];\n      }\n      setLoading(false);\n      return {\n        addresses: optimizedAddresses,\n        totalDistance,\n        isOptimized: true\n      };\n    } catch (err) {\n      setLoading(false);\n      const errorMessage = err instanceof Error ? err.message : 'Okänt fel vid optimering';\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [geocodeAddress, getDistanceMatrix, solveTSP]);\n  const generateGoogleMapsUrl = useCallback(addresses => {\n    if (addresses.length === 0) return '';\n    const encodedAddresses = addresses.map(addr => encodeURIComponent(addr));\n    return `https://www.google.com/maps/dir/${encodedAddresses.join('/')}`;\n  }, []);\n  return {\n    isLoaded,\n    loading,\n    error,\n    optimizeRoute,\n    generateGoogleMapsUrl\n  };\n};\n_s(useGoogleMaps, \"kdHVTcLfOSgln+4pFk+OJUN26wY=\");","map":{"version":3,"names":["useState","useCallback","useEffect","API_KEY","useGoogleMaps","_s","isLoaded","setIsLoaded","loading","setLoading","error","setError","loadGoogleMaps","window","google","maps","existingScripts","document","querySelectorAll","forEach","script","remove","createElement","src","async","defer","initGoogleMaps","onerror","head","appendChild","geocodeAddress","address","Promise","resolve","reject","Error","geocoder","Geocoder","geocode","results","status","location","geometry","lat","lng","getDistanceMatrix","coordinates","service","DistanceMatrixService","origins","map","coord","LatLng","destinations","travelMode","TravelMode","DRIVING","unitSystem","UnitSystem","METRIC","avoidHighways","avoidTolls","response","matrix","rows","row","elements","element","distance","value","solveTSP","distanceMatrix","n","length","visited","Array","fill","path","i","nearest","minDistance","Infinity","j","push","optimizeRoute","addresses","isOptimized","all","optimalOrder","optimizedAddresses","index","totalDistance","err","errorMessage","message","generateGoogleMapsUrl","encodedAddresses","addr","encodeURIComponent","join"],"sources":["/home/blixen66/Hämtningar/skoltransporter/skoltransport/src/hooks/useGoogleMaps.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { Address, OptimizationResult } from '../types';\n\ndeclare global {\n  interface Window {\n    google: any;\n    initGoogleMaps: () => void;\n  }\n}\n\nconst API_KEY = 'AIzaSyA94zp7rvXJarol8tn4eMPSy7yFvHIXeLg';\n\nexport const useGoogleMaps = () => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const loadGoogleMaps = () => {\n      if (window.google && window.google.maps) {\n        setIsLoaded(true);\n        return;\n      }\n\n      // Ta bort befintliga Google Maps scripts\n      const existingScripts = document.querySelectorAll('script[src*=\"maps.googleapis.com\"]');\n      existingScripts.forEach(script => script.remove());\n\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=places&callback=initGoogleMaps`;\n      script.async = true;\n      script.defer = true;\n      \n      // Skapa global callback funktion\n      window.initGoogleMaps = () => {\n        if (window.google && window.google.maps) {\n          setIsLoaded(true);\n          setError(null);\n        } else {\n          setError('Google Maps API laddades inte korrekt');\n        }\n      };\n      \n      script.onerror = () => {\n        setError('Kunde inte ladda Google Maps API');\n        setIsLoaded(false);\n      };\n\n      document.head.appendChild(script);\n    };\n\n    loadGoogleMaps();\n  }, []);\n\n  const geocodeAddress = useCallback((address: string): Promise<{ lat: number; lng: number }> => {\n    return new Promise((resolve, reject) => {\n      if (!window.google || !window.google.maps) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n\n      try {\n        const geocoder = new window.google.maps.Geocoder();\n        geocoder.geocode({ address }, (results: any, status: any) => {\n          if (status === 'OK' && results && results[0]) {\n            const location = results[0].geometry.location;\n            resolve({\n              lat: location.lat(),\n              lng: location.lng(),\n            });\n          } else {\n            reject(new Error(`Geocoding misslyckades: ${status}`));\n          }\n        });\n      } catch (error) {\n        reject(new Error(`Geocoding fel: ${error}`));\n      }\n    });\n  }, []);\n\n  const getDistanceMatrix = useCallback(async (coordinates: { lat: number; lng: number }[]): Promise<number[][]> => {\n    return new Promise((resolve, reject) => {\n      if (!window.google) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n\n      const service = new window.google.maps.DistanceMatrixService();\n      const origins = coordinates.map(coord => new window.google.maps.LatLng(coord.lat, coord.lng));\n      const destinations = [...origins];\n\n      service.getDistanceMatrix({\n        origins,\n        destinations,\n        travelMode: window.google.maps.TravelMode.DRIVING,\n        unitSystem: window.google.maps.UnitSystem.METRIC,\n        avoidHighways: false,\n        avoidTolls: false,\n      }, (response: any, status: any) => {\n        if (status === 'OK') {\n          const matrix = response.rows.map((row: any) =>\n            row.elements.map((element: any) => element.distance.value)\n          );\n          resolve(matrix);\n        } else {\n          reject(new Error(`Distance Matrix misslyckades: ${status}`));\n        }\n      });\n    });\n  }, []);\n\n  const solveTSP = useCallback((distanceMatrix: number[][]): number[] => {\n    const n = distanceMatrix.length;\n    if (n <= 1) return [0];\n\n    // Nearest Neighbor heuristik\n    const visited = new Array(n).fill(false);\n    const path = [0];\n    visited[0] = true;\n\n    for (let i = 1; i < n; i++) {\n      let nearest = -1;\n      let minDistance = Infinity;\n\n      for (let j = 0; j < n; j++) {\n        if (!visited[j]) {\n          const distance = distanceMatrix[path[path.length - 1]][j];\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearest = j;\n          }\n        }\n      }\n\n      if (nearest !== -1) {\n        path.push(nearest);\n        visited[nearest] = true;\n      }\n    }\n\n    return path;\n  }, []);\n\n  const optimizeRoute = useCallback(async (addresses: string[]): Promise<OptimizationResult> => {\n    if (addresses.length < 2) {\n      return {\n        addresses,\n        isOptimized: false,\n      };\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      // Geokoda alla adresser\n      const coordinates = await Promise.all(\n        addresses.map(address => geocodeAddress(address))\n      );\n\n      // Hämta avståndsmatris\n      const distanceMatrix = await getDistanceMatrix(coordinates);\n\n      // Lös TSP\n      const optimalOrder = solveTSP(distanceMatrix);\n\n      // Sortera adresser enligt optimal ordning\n      const optimizedAddresses = optimalOrder.map(index => addresses[index]);\n\n      // Beräkna totalt avstånd\n      let totalDistance = 0;\n      for (let i = 0; i < optimalOrder.length - 1; i++) {\n        totalDistance += distanceMatrix[optimalOrder[i]][optimalOrder[i + 1]];\n      }\n\n      setLoading(false);\n\n      return {\n        addresses: optimizedAddresses,\n        totalDistance,\n        isOptimized: true,\n      };\n    } catch (err) {\n      setLoading(false);\n      const errorMessage = err instanceof Error ? err.message : 'Okänt fel vid optimering';\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [geocodeAddress, getDistanceMatrix, solveTSP]);\n\n  const generateGoogleMapsUrl = useCallback((addresses: string[]): string => {\n    if (addresses.length === 0) return '';\n    \n    const encodedAddresses = addresses.map(addr => encodeURIComponent(addr));\n    return `https://www.google.com/maps/dir/${encodedAddresses.join('/')}`;\n  }, []);\n\n  return {\n    isLoaded,\n    loading,\n    error,\n    optimizeRoute,\n    generateGoogleMapsUrl,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}