{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nconst API_KEY = 'AIzaSyA94zp7rvXJarol8tn4eMPSy7yFvHIXeLg';\nexport const useGoogleMaps = () => {\n  _s();\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  useEffect(() => {\n    const loadGoogleMaps = () => {\n      if (window.google) {\n        setIsLoaded(true);\n        return;\n      }\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=places`;\n      script.async = true;\n      script.defer = true;\n      script.onload = () => {\n        setIsLoaded(true);\n      };\n      script.onerror = () => {\n        setError('Kunde inte ladda Google Maps API');\n      };\n      document.head.appendChild(script);\n    };\n    loadGoogleMaps();\n  }, []);\n  const geocodeAddress = useCallback(address => {\n    return new Promise((resolve, reject) => {\n      if (!window.google) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n      const geocoder = new window.google.maps.Geocoder();\n      geocoder.geocode({\n        address\n      }, (results, status) => {\n        if (status === 'OK' && results[0]) {\n          const location = results[0].geometry.location;\n          resolve({\n            lat: location.lat(),\n            lng: location.lng()\n          });\n        } else {\n          reject(new Error(`Geocoding misslyckades: ${status}`));\n        }\n      });\n    });\n  }, []);\n  const getDistanceMatrix = useCallback(async coordinates => {\n    return new Promise((resolve, reject) => {\n      if (!window.google) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n      const service = new window.google.maps.DistanceMatrixService();\n      const origins = coordinates.map(coord => new window.google.maps.LatLng(coord.lat, coord.lng));\n      const destinations = [...origins];\n      service.getDistanceMatrix({\n        origins,\n        destinations,\n        travelMode: window.google.maps.TravelMode.DRIVING,\n        unitSystem: window.google.maps.UnitSystem.METRIC,\n        avoidHighways: false,\n        avoidTolls: false\n      }, (response, status) => {\n        if (status === 'OK') {\n          const matrix = response.rows.map(row => row.elements.map(element => element.distance.value));\n          resolve(matrix);\n        } else {\n          reject(new Error(`Distance Matrix misslyckades: ${status}`));\n        }\n      });\n    });\n  }, []);\n  const solveTSP = useCallback(distanceMatrix => {\n    const n = distanceMatrix.length;\n    if (n <= 1) return [0];\n\n    // Nearest Neighbor heuristik\n    const visited = new Array(n).fill(false);\n    const path = [0];\n    visited[0] = true;\n    for (let i = 1; i < n; i++) {\n      let nearest = -1;\n      let minDistance = Infinity;\n      for (let j = 0; j < n; j++) {\n        if (!visited[j]) {\n          const distance = distanceMatrix[path[path.length - 1]][j];\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearest = j;\n          }\n        }\n      }\n      if (nearest !== -1) {\n        path.push(nearest);\n        visited[nearest] = true;\n      }\n    }\n    return path;\n  }, []);\n  const optimizeRoute = useCallback(async addresses => {\n    if (addresses.length < 2) {\n      return {\n        addresses,\n        isOptimized: false\n      };\n    }\n    setLoading(true);\n    setError(null);\n    try {\n      // Geokoda alla adresser\n      const coordinates = await Promise.all(addresses.map(address => geocodeAddress(address)));\n\n      // Hämta avståndsmatris\n      const distanceMatrix = await getDistanceMatrix(coordinates);\n\n      // Lös TSP\n      const optimalOrder = solveTSP(distanceMatrix);\n\n      // Sortera adresser enligt optimal ordning\n      const optimizedAddresses = optimalOrder.map(index => addresses[index]);\n\n      // Beräkna totalt avstånd\n      let totalDistance = 0;\n      for (let i = 0; i < optimalOrder.length - 1; i++) {\n        totalDistance += distanceMatrix[optimalOrder[i]][optimalOrder[i + 1]];\n      }\n      setLoading(false);\n      return {\n        addresses: optimizedAddresses,\n        totalDistance,\n        isOptimized: true\n      };\n    } catch (err) {\n      setLoading(false);\n      const errorMessage = err instanceof Error ? err.message : 'Okänt fel vid optimering';\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [geocodeAddress, getDistanceMatrix, solveTSP]);\n  const generateGoogleMapsUrl = useCallback(addresses => {\n    if (addresses.length === 0) return '';\n    const encodedAddresses = addresses.map(addr => encodeURIComponent(addr));\n    return `https://www.google.com/maps/dir/${encodedAddresses.join('/')}`;\n  }, []);\n  return {\n    isLoaded,\n    loading,\n    error,\n    optimizeRoute,\n    generateGoogleMapsUrl\n  };\n};\n_s(useGoogleMaps, \"kdHVTcLfOSgln+4pFk+OJUN26wY=\");","map":{"version":3,"names":["useState","useCallback","useEffect","API_KEY","useGoogleMaps","_s","isLoaded","setIsLoaded","loading","setLoading","error","setError","loadGoogleMaps","window","google","script","document","createElement","src","async","defer","onload","onerror","head","appendChild","geocodeAddress","address","Promise","resolve","reject","Error","geocoder","maps","Geocoder","geocode","results","status","location","geometry","lat","lng","getDistanceMatrix","coordinates","service","DistanceMatrixService","origins","map","coord","LatLng","destinations","travelMode","TravelMode","DRIVING","unitSystem","UnitSystem","METRIC","avoidHighways","avoidTolls","response","matrix","rows","row","elements","element","distance","value","solveTSP","distanceMatrix","n","length","visited","Array","fill","path","i","nearest","minDistance","Infinity","j","push","optimizeRoute","addresses","isOptimized","all","optimalOrder","optimizedAddresses","index","totalDistance","err","errorMessage","message","generateGoogleMapsUrl","encodedAddresses","addr","encodeURIComponent","join"],"sources":["/home/blixen66/Hämtningar/skoltransporter/skoltransport/src/hooks/useGoogleMaps.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { Address, OptimizationResult } from '../types';\n\ndeclare global {\n  interface Window {\n    google: any;\n    initGoogleMaps: () => void;\n  }\n}\n\nconst API_KEY = 'AIzaSyA94zp7rvXJarol8tn4eMPSy7yFvHIXeLg';\n\nexport const useGoogleMaps = () => {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const loadGoogleMaps = () => {\n      if (window.google) {\n        setIsLoaded(true);\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${API_KEY}&libraries=places`;\n      script.async = true;\n      script.defer = true;\n      \n      script.onload = () => {\n        setIsLoaded(true);\n      };\n      \n      script.onerror = () => {\n        setError('Kunde inte ladda Google Maps API');\n      };\n\n      document.head.appendChild(script);\n    };\n\n    loadGoogleMaps();\n  }, []);\n\n  const geocodeAddress = useCallback((address: string): Promise<{ lat: number; lng: number }> => {\n    return new Promise((resolve, reject) => {\n      if (!window.google) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n\n      const geocoder = new window.google.maps.Geocoder();\n      geocoder.geocode({ address }, (results: any, status: any) => {\n        if (status === 'OK' && results[0]) {\n          const location = results[0].geometry.location;\n          resolve({\n            lat: location.lat(),\n            lng: location.lng(),\n          });\n        } else {\n          reject(new Error(`Geocoding misslyckades: ${status}`));\n        }\n      });\n    });\n  }, []);\n\n  const getDistanceMatrix = useCallback(async (coordinates: { lat: number; lng: number }[]): Promise<number[][]> => {\n    return new Promise((resolve, reject) => {\n      if (!window.google) {\n        reject(new Error('Google Maps API inte laddad'));\n        return;\n      }\n\n      const service = new window.google.maps.DistanceMatrixService();\n      const origins = coordinates.map(coord => new window.google.maps.LatLng(coord.lat, coord.lng));\n      const destinations = [...origins];\n\n      service.getDistanceMatrix({\n        origins,\n        destinations,\n        travelMode: window.google.maps.TravelMode.DRIVING,\n        unitSystem: window.google.maps.UnitSystem.METRIC,\n        avoidHighways: false,\n        avoidTolls: false,\n      }, (response: any, status: any) => {\n        if (status === 'OK') {\n          const matrix = response.rows.map((row: any) =>\n            row.elements.map((element: any) => element.distance.value)\n          );\n          resolve(matrix);\n        } else {\n          reject(new Error(`Distance Matrix misslyckades: ${status}`));\n        }\n      });\n    });\n  }, []);\n\n  const solveTSP = useCallback((distanceMatrix: number[][]): number[] => {\n    const n = distanceMatrix.length;\n    if (n <= 1) return [0];\n\n    // Nearest Neighbor heuristik\n    const visited = new Array(n).fill(false);\n    const path = [0];\n    visited[0] = true;\n\n    for (let i = 1; i < n; i++) {\n      let nearest = -1;\n      let minDistance = Infinity;\n\n      for (let j = 0; j < n; j++) {\n        if (!visited[j]) {\n          const distance = distanceMatrix[path[path.length - 1]][j];\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearest = j;\n          }\n        }\n      }\n\n      if (nearest !== -1) {\n        path.push(nearest);\n        visited[nearest] = true;\n      }\n    }\n\n    return path;\n  }, []);\n\n  const optimizeRoute = useCallback(async (addresses: string[]): Promise<OptimizationResult> => {\n    if (addresses.length < 2) {\n      return {\n        addresses,\n        isOptimized: false,\n      };\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      // Geokoda alla adresser\n      const coordinates = await Promise.all(\n        addresses.map(address => geocodeAddress(address))\n      );\n\n      // Hämta avståndsmatris\n      const distanceMatrix = await getDistanceMatrix(coordinates);\n\n      // Lös TSP\n      const optimalOrder = solveTSP(distanceMatrix);\n\n      // Sortera adresser enligt optimal ordning\n      const optimizedAddresses = optimalOrder.map(index => addresses[index]);\n\n      // Beräkna totalt avstånd\n      let totalDistance = 0;\n      for (let i = 0; i < optimalOrder.length - 1; i++) {\n        totalDistance += distanceMatrix[optimalOrder[i]][optimalOrder[i + 1]];\n      }\n\n      setLoading(false);\n\n      return {\n        addresses: optimizedAddresses,\n        totalDistance,\n        isOptimized: true,\n      };\n    } catch (err) {\n      setLoading(false);\n      const errorMessage = err instanceof Error ? err.message : 'Okänt fel vid optimering';\n      setError(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }, [geocodeAddress, getDistanceMatrix, solveTSP]);\n\n  const generateGoogleMapsUrl = useCallback((addresses: string[]): string => {\n    if (addresses.length === 0) return '';\n    \n    const encodedAddresses = addresses.map(addr => encodeURIComponent(addr));\n    return `https://www.google.com/maps/dir/${encodedAddresses.join('/')}`;\n  }, []);\n\n  return {\n    isLoaded,\n    loading,\n    error,\n    optimizeRoute,\n    generateGoogleMapsUrl,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}